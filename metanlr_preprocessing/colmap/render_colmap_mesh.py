"""
Render a ply file generated by COLMAP, from COLMAP poses.
"""

from pathlib import Path
import argparse
import os
import sys
if sys.platform.startswith("linux"):
    os.environ["PYOPENGL_PLATFORM"] = "osmesa"  # nopep8

import trimesh
import pyrender
import imageio
import numpy as np
from scipy.spatial.transform import Rotation as R

if __name__ == "__main__":
    import sys
    sys.path.append(str(Path(__file__).parent.parent.parent.parent))

from data_processing.components.colmap.colmap_read_write_model import read_cameras_binary, read_images_binary, qvec2rotmat
from data_processing.components.colmap.colmap_utils import intrinsics_from_camera, extrinsics_from_image
from utils import math_utils


def main():
    """
    Render the images.
    """
    parser = argparse.ArgumentParser("Shows PCD")
    parser.add_argument("mesh_file", type=Path, help="Mesh PLY.")
    parser.add_argument("camera_file", type=Path, help="camera.bin")
    parser.add_argument("--colors", type=int, default=1, help="Use colors?")
    opt = parser.parse_args()

    background_color = [1.0, 1.0, 1.0]
    if opt.colors:
        scene = pyrender.Scene(ambient_light=[0, 0, 0], bg_color=background_color)
    else:
        scene = pyrender.Scene(ambient_light=[.2, .2, .2], bg_color=background_color)

    # Mesh
    print(f'Loading {opt.mesh_file}...')
    mesh = pyrender.Mesh.from_trimesh(trimesh.load_mesh(opt.mesh_file), smooth=True)
    if not opt.colors:
        mesh.primitives[0].material = pyrender.MetallicRoughnessMaterial(
            # alphaMode='BLEND',
            #emissiveFactor=(0, 0, 0),
            metallicFactor=0,
            # roughnessFactor=0.1,
            #baseColorFactor=(1, 1, 1, 1)
        )
        mesh.primitives[0].color_0 = None  # mesh.primitives[0].color_0 * 0 + 1
    scene.add(mesh, pose=np.eye(4))

    colmap_cameras = read_cameras_binary(opt.camera_file)

    # Create a PyRender camera corresponding to each Camera extrinsics.
    pyrender_cameras = {}
    for camera_id, colmap_camera in colmap_cameras.items():
        intrinsics, distortion_coeffs = intrinsics_from_camera(colmap_camera)
        pyrender_camera = pyrender.IntrinsicsCamera(intrinsics[0, 0], intrinsics[1, 1],
                                                    intrinsics[0, 2] - 0.5, intrinsics[1, 2] - 0.5,
                                                    zfar=10000)

        pyrender_cameras[camera_id] = pyrender_camera

    images = read_images_binary(opt.camera_file.parent / "images.bin")

    if opt.colors:
        render_path = opt.mesh_file.parent / "rendered"
    else:
        render_path = opt.mesh_file.parent / "rendered_shape"
    render_path.mkdir(exist_ok=True)

    views = []
    for i, image in enumerate(images.values()):
        pyrender_camera = pyrender_cameras[image.camera_id]
        colmap_camera = colmap_cameras[image.camera_id]
        resolution = (colmap_camera.width, colmap_camera.height)

        extr = extrinsics_from_image(image)

        def mflip(x, y, z):
            transform = np.eye(4, dtype=np.float32)
            transform[0, 0] = x
            transform[1, 1] = y
            transform[2, 2] = z
            return transform

        # v = np.concatenate([mesh.primitives[0].positions.mean(0), [1.0]])
        m_view = mflip(1, -1, -1) @ extr @ mflip(1, 1, 1)

        views += [(
            {
                'name': Path(image.name).stem,
                'camera': pyrender_camera,
                'resolution': resolution,
                'view_matrix': m_view
            },
            Path(image.name).stem
        )]

    views = sorted(views, key=lambda x: x[1])
    views = [x[0] for x in views]

    if not opt.colors:
        # Lights.
        # Front.
        light = pyrender.DirectionalLight(color=[1, 1, 1], intensity=550)
        light_pose = np.eye(4)
        light_pose[:3, :3] = R.from_euler('xy', [-45 + 180, 10], degrees=True).as_matrix()
        scene.add(light, pose=light_pose)

        # Rear.
        light = pyrender.DirectionalLight(color=[1, 1, 1], intensity=120)
        light_pose = np.eye(4)
        light_pose[:3, :3] = R.from_euler('xy', [0 + 180, -10], degrees=True).as_matrix()
        scene.add(light, pose=light_pose)

    # Render.
    for i, view in enumerate(views):

        camera_node = scene.add(view['camera'], pose=np.linalg.inv(view['view_matrix']))

        resolution = np.array(view['resolution'])
        renderer = pyrender.OffscreenRenderer(*resolution)
        flags = pyrender.constants.RenderFlags.FLAT if opt.colors else pyrender.constants.RenderFlags.NONE
        im_out, _ = renderer.render(scene, flags)
        print(im_out.mean((0, 1)))

        scene.remove_node(camera_node)

        out_file = render_path / f"{i:03d}_{view['name']}.png"
        print(f'Saving {out_file}...')
        imageio.imwrite(out_file, im_out)


if __name__ == "__main__":
    main()
